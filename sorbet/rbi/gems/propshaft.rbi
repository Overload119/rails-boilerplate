# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/propshaft/all/propshaft.rbi
#
# propshaft-1.3.1

module Propshaft
  def logger; end
  def logger=(val); end
  def self.logger; end
  def self.logger=(val); end
end
class Propshaft::Manifest
  def <<(entry); end
  def [](logical_path); end
  def delete(logical_path); end
  def initialize(integrity_hash_algorithm: nil); end
  def integrity_hash_algorithm; end
  def push(entry); end
  def push_asset(asset); end
  def self.from_path(manifest_path); end
  def to_json; end
  def transform_values(&block); end
end
class Propshaft::Manifest::ManifestEntry
  def digested_path; end
  def initialize(logical_path:, digested_path:, integrity:); end
  def integrity; end
  def logical_path; end
  def to_h; end
end
class Propshaft::Asset
  def ==(other_asset); end
  def already_digested?; end
  def compiled_content; end
  def content(encoding: nil); end
  def content_type; end
  def content_with_compile_references; end
  def digest; end
  def digested_path; end
  def fresh?(digest); end
  def initialize(path, logical_path:, load_path:); end
  def integrity(hash_algorithm:); end
  def length; end
  def load_path; end
  def logical_path; end
  def path; end
  def self.extract_path_and_digest(digested_path); end
end
class Propshaft::LoadPath
  def all_files_from_tree(path); end
  def asset_paths_by_glob(glob); end
  def asset_paths_by_type(content_type); end
  def assets; end
  def assets_by_path; end
  def cache_sweeper; end
  def clear_cache; end
  def compilers; end
  def dedup(paths); end
  def extract_logical_paths_from(assets); end
  def find(asset_name); end
  def find_referenced_by(asset); end
  def initialize(paths = nil, compilers:, version: nil, file_watcher: nil, integrity_hash_algorithm: nil); end
  def integrity_hash_algorithm; end
  def manifest; end
  def paths; end
  def seed_cache; end
  def version; end
  def without_dotfiles(files); end
end
class Propshaft::LoadPath::NullFileWatcher
  def execute_if_updated; end
  def initialize(paths, files_to_watch, &block); end
end
module Propshaft::Resolver
end
class Propshaft::Resolver::Dynamic
  def find_asset(logical_path); end
  def initialize(load_path:, prefix:); end
  def integrity(logical_path); end
  def load_path; end
  def prefix; end
  def read(logical_path, options = nil); end
  def resolve(logical_path); end
end
class Propshaft::Resolver::Static
  def digested_path(logical_path); end
  def initialize(manifest_path:, prefix:); end
  def integrity(logical_path); end
  def manifest; end
  def manifest_path; end
  def prefix; end
  def read(logical_path, encoding: nil); end
  def resolve(logical_path); end
end
class Propshaft::Server
  def call(env); end
  def execute_cache_sweeper_if_updated; end
  def extract_path_and_digest(path); end
  def initialize(app, assembly); end
  def inspect; end
end
class Propshaft::OutputPath
  def all_files_from_tree(path); end
  def clean(count, age); end
  def files; end
  def fresh_version_within_limit(mtime, count, expires_at:, limit:); end
  def initialize(path, manifest); end
  def manifest; end
  def path; end
  def remove(path); end
end
class Propshaft::Processor
  def clean(count); end
  def clobber; end
  def compile_asset(asset); end
  def compilers; end
  def copy_asset(asset); end
  def ensure_output_path_exists; end
  def initialize(load_path:, output_path:, compilers:, manifest_path:); end
  def load_path; end
  def manifest_path; end
  def output_asset(asset); end
  def output_assets; end
  def output_path; end
  def process; end
  def write_manifest; end
end
class Propshaft::Compilers
  def any?; end
  def assembly; end
  def compilable?(asset); end
  def compile(asset); end
  def initialize(assembly); end
  def referenced_by(asset); end
  def register(mime_type, klass); end
  def registrations; end
end
class Propshaft::Compiler
  def assembly; end
  def compile(asset, input); end
  def config(*, **, &); end
  def initialize(assembly); end
  def load_path(*, **, &); end
  def referenced_by(asset); end
  def url_prefix; end
end
class Propshaft::Compiler::CssAssetUrls < Propshaft::Compiler
  def asset_url(resolved_path, logical_path, fingerprint, pattern); end
  def compile(asset, input); end
  def referenced_by(asset, references: nil); end
  def resolve_path(directory, filename); end
end
class Propshaft::Compiler::JsAssetUrls < Propshaft::Compiler
  def asset_url(resolved_path, logical_path, fingerprint, pattern); end
  def compile(asset, input); end
  def referenced_by(asset, references: nil); end
  def resolve_path(directory, filename); end
end
class Propshaft::Compiler::SourceMappingUrls < Propshaft::Compiler
  def asset_path(source_mapping_url, logical_path); end
  def compile(asset, input); end
  def source_mapping_url(logical_path, resolved_path, comment_start, comment_end); end
end
class Propshaft::Assembly
  def compilers; end
  def config; end
  def initialize(config); end
  def load_path; end
  def prefix; end
  def processor; end
  def resolver; end
  def reveal(path_type = nil); end
end
class Propshaft::Error < StandardError
end
class Propshaft::MissingAssetError < Propshaft::Error
  def initialize(path); end
  def message; end
end
module Propshaft::Helper
  def _build_asset_tags(sources, options, asset_type); end
  def _compute_integrity?(options); end
  def _path_with_extname(path, options); end
  def _secure_subresource_integrity_context?; end
  def all_stylesheets_paths; end
  def app_stylesheets_paths; end
  def asset_integrity(path, options = nil); end
  def compute_asset_path(path, options = nil); end
  def javascript_include_tag(*sources); end
  def stylesheet_link_tag(*sources); end
end
class Propshaft::QuietAssets
  def call(env); end
  def initialize(app); end
end
class Propshaft::Railtie < Rails::Railtie
end
