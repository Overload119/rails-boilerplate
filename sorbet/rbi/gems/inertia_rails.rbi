# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/inertia_rails/all/inertia_rails.rbi
#
# inertia_rails-3.15.0

module InertiaRails
  def self.always(&block); end
  def self.configuration; end
  def self.configure; end
  def self.deep_merge(match_on: nil, &block); end
  def self.defer(*, **, &); end
  def self.deprecator; end
  def self.lazy(value = nil, &block); end
  def self.merge(*, **, &); end
  def self.once(*, **, &); end
  def self.optional(&block); end
  def self.scroll(metadata = nil, **options, &block); end
end
module InertiaRails::PropOnceable
  def expires_at; end
  def fresh?; end
  def initialize(**props, &block); end
  def once?; end
  def once_expires_in; end
  def once_key; end
end
module InertiaRails::PropMergeable
  def append(path, match_on: nil); end
  def appends_at_paths; end
  def appends_at_root?; end
  def deep_merge?; end
  def initialize(**props, &block); end
  def match_on; end
  def merge?; end
  def merges_at_root?; end
  def prepend(path, match_on: nil); end
  def prepends_at_paths; end
  def prepends_at_root?; end
end
class InertiaRails::BaseProp
  def call(controller); end
  def initialize(**, &block); end
end
class InertiaRails::IgnoreOnFirstLoadProp < InertiaRails::BaseProp
end
class InertiaRails::AlwaysProp < InertiaRails::BaseProp
end
class InertiaRails::LazyProp < InertiaRails::IgnoreOnFirstLoadProp
  def call(controller); end
  def initialize(value = nil, &block); end
  def value; end
end
class InertiaRails::OptionalProp < InertiaRails::IgnoreOnFirstLoadProp
end
class InertiaRails::DeferProp < InertiaRails::IgnoreOnFirstLoadProp
  def group; end
  def initialize(**props, &block); end
end
class InertiaRails::MergeProp < InertiaRails::BaseProp
  def initialize(**props, &block); end
end
class InertiaRails::OnceProp < InertiaRails::BaseProp
  def initialize(**props, &block); end
end
module InertiaRails::ScrollMetadata
  def self.adapters; end
  def self.adapters=(arg0); end
  def self.extract(metadata, **options); end
  def self.register_adapter(adapter); end
end
class InertiaRails::ScrollMetadata::MissingMetadataAdapterError < StandardError
end
class InertiaRails::ScrollMetadata::Props
  def as_json(_options = nil); end
  def initialize(page_name:, previous_page:, next_page:, current_page:); end
end
class InertiaRails::ScrollMetadata::KaminariAdapter
  def call(metadata, **_options); end
  def match?(metadata); end
end
class InertiaRails::ScrollMetadata::PagyAdapter
  def call(metadata, **_options); end
  def match?(metadata); end
end
class InertiaRails::ScrollMetadata::HashAdapter
  def call(metadata, **_options); end
  def match?(metadata); end
end
class InertiaRails::ScrollProp < InertiaRails::BaseProp
  def call(controller); end
  def configure_merge_intent(scroll_intent); end
  def initialize(**props, &block); end
  def metadata; end
end
class InertiaRails::Configuration
  def always_include_errors_hash; end
  def always_include_errors_hash=(value); end
  def bind_controller(controller); end
  def component_path_resolver(path:, action:); end
  def component_path_resolver=(value); end
  def controller; end
  def deep_merge_shared_data; end
  def deep_merge_shared_data=(value); end
  def default_render; end
  def default_render=(value); end
  def encrypt_history; end
  def encrypt_history=(value); end
  def evaluate_option(value); end
  def freeze; end
  def initialize(controller: nil, **attrs); end
  def layout; end
  def layout=(value); end
  def merge!(config); end
  def merge(config); end
  def options; end
  def parent_controller; end
  def parent_controller=(value); end
  def prop_transformer(props:); end
  def prop_transformer=(value); end
  def root_dom_id; end
  def root_dom_id=(value); end
  def self.default; end
  def self.env_options; end
  def ssr_enabled; end
  def ssr_enabled=(value); end
  def ssr_url; end
  def ssr_url=(value); end
  def use_script_element_for_initial_page; end
  def use_script_element_for_initial_page=(value); end
  def version; end
  def version=(value); end
  def with_defaults(config); end
end
class InertiaRails::MetaTag
  def [](key); end
  def as_json(_options = nil); end
  def determine_tag_type(type); end
  def generate_head_key; end
  def generate_meta_head_key; end
  def initialize(tag_name: nil, head_key: nil, allow_duplicates: nil, type: nil, **tag_data); end
  def shortened_title_tag?(tag_name, tag_data); end
  def tag_digest; end
  def tag_script_inner_content(content); end
  def to_tag(tag_helper); end
end
class InertiaRails::Renderer
  def all_merge_props; end
  def append_merge_props(props); end
  def clear_history; end
  def component; end
  def computed_props; end
  def configuration; end
  def controller; end
  def deep_transform_props(props, parent_path = nil); end
  def deferred_props_keys; end
  def encrypt_history; end
  def except_once_keys; end
  def excluded_by_except_partial_keys?(path_with_prefixes); end
  def excluded_by_once_cache?(prop, path); end
  def excluded_by_only_partial_keys?(path_with_prefixes); end
  def excluded_by_partial_request?(path); end
  def explicitly_requested?(path); end
  def initialize(component, controller, request, response, render_method, **options); end
  def keep_prop?(prop, path); end
  def layout; end
  def merge_props(shared_props, props, deep_merge); end
  def meta_tags; end
  def page; end
  def partial_except_keys; end
  def partial_keys; end
  def path_prefixes(parts); end
  def prepend_merge_props(props); end
  def props; end
  def render; end
  def render_ssr; end
  def rendering_partial_component?; end
  def requested_merge_props; end
  def reset_keys; end
  def resolve_component(component); end
  def resolve_match_on_props; end
  def resolve_merge_props; end
  def resolve_once_props; end
  def scroll_props; end
  def shared_data; end
  def view_data; end
end
class InertiaRails::Middleware
  def call(env); end
  def initialize(app); end
end
class InertiaRails::Middleware::InertiaRailsRequest
  def client_version; end
  def coerce_version(version); end
  def controller; end
  def copy_xsrf_to_csrf!; end
  def force_refresh(request); end
  def get?; end
  def inertia_non_post_redirect?(status); end
  def inertia_request?; end
  def initialize(app, env); end
  def keep_inertia_session_options?(status); end
  def non_get_redirectable_method?; end
  def redirect_status?(status); end
  def request_method; end
  def response; end
  def server_version; end
  def stale_inertia_get?; end
  def stale_inertia_request?; end
  def version_stale?; end
end
module InertiaRails::Helper
  def inertia_headers; end
  def inertia_meta_tags; end
  def inertia_page; end
  def inertia_rendering?; end
  def inertia_root(id: nil, page: nil); end
  def inertia_ssr_head; end
end
class InertiaRails::ActionFilter
  def initialize(conditional_key, actions); end
  def match?(controller); end
end
class InertiaRails::MetaTagBuilder
  def add(meta_tag); end
  def add_new_tag(new_tag_data); end
  def clear; end
  def initialize(controller); end
  def meta_tags; end
  def remove(head_key = nil, &block); end
end
module InertiaRails::Controller
  def capture_inertia_session_options(options); end
  def default_render; end
  def inertia_configuration; end
  def inertia_location(url); end
  def inertia_meta; end
  def inertia_shared_data; end
  def inertia_view_assigns; end
  def redirect_to(options = nil, response_options = nil); end
  extend ActiveSupport::Concern
end
module InertiaRails::Controller::ClassMethods
  def _inertia_configuration; end
  def _inertia_shared_data; end
  def extract_inertia_share_options(props); end
  def filter_to_proc(filter); end
  def inertia_config(**attrs); end
  def inertia_share(hash = nil, **props, &block); end
  def push_to_inertia_share(**attrs, &block); end
  def transform_inertia_share_option(options, from, to); end
  def use_inertia_instance_props; end
end
class InertiaRails::Engine < Rails::Engine
end
module InertiaRails::InertiaDebugExceptions
  def render_for_browser_request(request, wrapper); end
end
module InertiaRails::InertiaBetterErrors
  def text?(env); end
end
module InertiaRails::InertiaRequest
  def inertia?; end
  def inertia_partial?; end
end
class ActionDispatch::Request
  include InertiaRails::InertiaRequest
end
module InertiaRails::InertiaMapper
  def extract_route_and_component(path); end
  def inertia(*args, **options); end
end
class ActionDispatch::Routing::Mapper
  include InertiaRails::InertiaMapper
end
module ActionController::Renderers
  def _render_with_renderer_inertia(component, options); end
end
class InertiaRails::Error < StandardError
end
class InertiaRails::StaticController < ApplicationController
  def _layout(lookup_context, formats, keys); end
  def self.__class_attr__wrapper_options; end
  def self.__class_attr__wrapper_options=(new_value); end
  def self.__class_attr_helpers_path; end
  def self.__class_attr_helpers_path=(new_value); end
  def self.__class_attr_middleware_stack; end
  def self.__class_attr_middleware_stack=(new_value); end
  def static; end
  include Anonymous_Module_29
end
