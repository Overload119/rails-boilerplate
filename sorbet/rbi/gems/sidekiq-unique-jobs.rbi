# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/sidekiq-unique-jobs/all/sidekiq-unique-jobs.rbi
#
# sidekiq-unique-jobs-8.0.12

module SidekiqUniqueJobs
  def config; end
  def configure(options = nil); end
  def constantize(str); end
  def disable!(&block); end
  def disabled?; end
  def enable!(&block); end
  def enabled?; end
  def fetch_redis_version; end
  def locks; end
  def logger; end
  def logger=(other); end
  def logging?; end
  def now; end
  def now_f; end
  def reflect; end
  def reflections; end
  def reset!; end
  def safe_constantize(str); end
  def self.config; end
  def self.configure(options = nil); end
  def self.constantize(str); end
  def self.disable!(&block); end
  def self.disabled?; end
  def self.enable!(&block); end
  def self.enabled?; end
  def self.fetch_redis_version; end
  def self.locks; end
  def self.logger; end
  def self.logger=(other); end
  def self.logging?; end
  def self.now; end
  def self.now_f; end
  def self.reflect; end
  def self.reflections; end
  def self.reset!; end
  def self.safe_constantize(str); end
  def self.strategies; end
  def self.toggle(enabled); end
  def self.use_config(tmp_config = nil); end
  def self.validate_worker!(options); end
  def self.validate_worker(options); end
  def self.version; end
  def strategies; end
  def toggle(enabled); end
  def use_config(tmp_config = nil); end
  def validate_worker!(options); end
  def validate_worker(options); end
  def version; end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Connection
end
module SidekiqUniqueJobs::Script
  def self.logger; end
  def self.logger=(other); end
  extend SidekiqUniqueJobs::Script::DSL::ClassMethods
  include SidekiqUniqueJobs::Script::DSL
end
class SidekiqUniqueJobs::Script::Template
  def include_partial(relative_path); end
  def initialize(script_path); end
  def render(pathname); end
end
class SidekiqUniqueJobs::Script::Misconfiguration < RuntimeError
end
class SidekiqUniqueJobs::Script::LuaError < RuntimeError
  def backtrace_before_entering_gem(backtrace); end
  def content; end
  def error; end
  def file; end
  def generate_backtrace(file, line_number); end
  def generate_error_context(content, line_number); end
  def initialize(error, script); end
  def line_from_gem(line); end
  def self.intercepts?(error); end
end
class SidekiqUniqueJobs::Script::Script
  def ==(other); end
  def call_count; end
  def changed?; end
  def compiled_sha; end
  def increment_call_count; end
  def initialize(name:, root_path:); end
  def load(conn); end
  def name; end
  def path; end
  def render_file; end
  def root_path; end
  def self.load(name, root_path, conn); end
  def sha; end
  def source; end
end
class SidekiqUniqueJobs::Script::Scripts
  def count; end
  def delete(script); end
  def execute(name, conn, keys: nil, argv: nil); end
  def fetch(name, conn); end
  def initialize(path); end
  def kill(conn); end
  def load(name, conn); end
  def root_path; end
  def scripts; end
  def self.fetch(root_path); end
end
class SidekiqUniqueJobs::Script::Config
  def initialize; end
  def logger; end
  def logger=(obj); end
  def scripts_path; end
  def scripts_path=(obj); end
end
module SidekiqUniqueJobs::Script::Timing
  def now; end
  def self.now; end
  def self.timed; end
  def timed; end
end
module SidekiqUniqueJobs::Script::Logging
  def log_debug(message_or_exception = nil, &block); end
  def log_error(message_or_exception = nil, &block); end
  def log_fatal(message_or_exception = nil, &block); end
  def log_info(message_or_exception = nil, &block); end
  def log_warn(message_or_exception = nil, &block); end
  def logger; end
  def self.included(base); end
end
module SidekiqUniqueJobs::Script::DSL
  def self.included(base); end
end
module SidekiqUniqueJobs::Script::DSL::ClassMethods
  def config; end
  def configure(options = nil); end
  def execute(file_name, conn, keys: nil, argv: nil); end
end
class SidekiqUniqueJobs::Script::Client
  def config; end
  def execute(script_name, conn, keys: nil, argv: nil, retries: nil); end
  def handle_busy(conn); end
  def handle_error(script_name, conn, ex); end
  def handle_noscript(script_name); end
  def initialize(config); end
  def logger; end
  def scripts; end
  include SidekiqUniqueJobs::Script::Timing
end
class SidekiqUniqueJobs::Deprecation
  def self.muted; end
  def self.muted?; end
  def self.warn(msg); end
  def self.warn_with_backtrace(msg); end
end
class SidekiqUniqueJobs::Reflections
  def after_unlock_callback_failed(*args, &block); end
  def configured?(reflection); end
  def debug(*args, &block); end
  def dispatch(reflection, *args); end
  def duplicate(*args, &block); end
  def error(*args, &block); end
  def execution_failed(*args, &block); end
  def initialize; end
  def lock_failed(*args, &block); end
  def locked(*args, &block); end
  def misconfigured?(reflection); end
  def reschedule_failed(*args, &block); end
  def rescheduled(*args, &block); end
  def timeout(*args, &block); end
  def unknown_sidekiq_worker(*args, &block); end
  def unlock_failed(*args, &block); end
  def unlocked(*args, &block); end
end
module SidekiqUniqueJobs::Reflectable
  def reflect(reflection, *args); end
end
class SidekiqUniqueJobs::TimerTask < Concurrent::RubyExecutorService
  def <<(task); end
  def execute; end
  def execute_task(completion); end
  def execution_interval; end
  def execution_interval=(value); end
  def initialize(opts = nil, &task); end
  def ns_initialize(opts, &task); end
  def ns_kill_execution; end
  def ns_shutdown_execution; end
  def post(*args, &task); end
  def running?; end
  def schedule_next_task(interval = nil); end
  def self.execute(opts = nil, &task); end
  include Concurrent::Concern::Dereferenceable
  include Concurrent::Concern::Observable
end
class SidekiqUniqueJobs::VersionCheck
  def compare(expected, operator); end
  def constraints; end
  def initialize(version, constraint); end
  def match; end
  def operator_one; end
  def operator_two; end
  def satisfied?; end
  def self.satisfied?(version, constraint); end
  def self.unfulfilled?(version, constraint); end
  def version; end
  def version_one; end
  def version_two; end
end
module SidekiqUniqueJobs::JSON
  def dump_json(object); end
  def load_json(string); end
  def safe_load_json(string); end
  def self.dump_json(object); end
  def self.load_json(string); end
  def self.safe_load_json(string); end
end
module SidekiqUniqueJobs::Logging
  def build_message(message_or_exception, item = nil); end
  def fake_logger_context(_context); end
  def log_debug(message_or_exception = nil, item = nil, &block); end
  def log_error(message_or_exception = nil, item = nil, &block); end
  def log_fatal(message_or_exception = nil, item = nil, &block); end
  def log_info(message_or_exception = nil, item = nil, &block); end
  def log_warn(message_or_exception = nil, item = nil, &block); end
  def logger; end
  def logger_context_hash?; end
  def logger_method; end
  def logger_respond_to_with_context?; end
  def logging?; end
  def logging_context; end
  def no_sidekiq_context_method; end
  def self.included(base); end
  def sidekiq_context_method; end
  def sidekiq_logger_context_method; end
  def sidekiq_logging_context_method; end
  def with_configured_loggers_context(&block); end
  def with_logging_context; end
end
module SidekiqUniqueJobs::Logging::Middleware
  def logging_context; end
  def self.included(base); end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Logging
end
module SidekiqUniqueJobs::Timing
  def clock_stamp; end
  def now_f; end
  def self.clock_stamp; end
  def self.now_f; end
  def self.time_source; end
  def self.timed; end
  def time_source; end
  def timed; end
end
module SidekiqUniqueJobs::SidekiqWorkerMethods
  def after_unlock_hook; end
  def default_job_options; end
  def job_class; end
  def job_class=(obj); end
  def job_class_constantize(klazz = nil); end
  def job_method_defined?(method_sym); end
  def job_options; end
  def sidekiq_job_class?; end
end
module SidekiqUniqueJobs::Connection
  def redis(_r_pool = nil, &block); end
  def self.included(base); end
end
class SidekiqUniqueJobs::UniqueJobsError < RuntimeError
end
class SidekiqUniqueJobs::Conflict < SidekiqUniqueJobs::UniqueJobsError
  def initialize(item); end
end
class SidekiqUniqueJobs::NoBlockGiven < SidekiqUniqueJobs::UniqueJobsError
end
class SidekiqUniqueJobs::NoSuchNotificationError < SidekiqUniqueJobs::UniqueJobsError
end
class SidekiqUniqueJobs::DuplicateLock < SidekiqUniqueJobs::UniqueJobsError
end
class SidekiqUniqueJobs::DuplicateStrategy < SidekiqUniqueJobs::UniqueJobsError
end
class SidekiqUniqueJobs::InvalidArgument < SidekiqUniqueJobs::UniqueJobsError
end
class SidekiqUniqueJobs::InvalidWorker < SidekiqUniqueJobs::UniqueJobsError
  def initialize(lock_config); end
end
class SidekiqUniqueJobs::InvalidUniqueArguments < SidekiqUniqueJobs::UniqueJobsError
  def initialize(options); end
end
class SidekiqUniqueJobs::NotUniqueWorker < SidekiqUniqueJobs::UniqueJobsError
  def initialize(options); end
end
class SidekiqUniqueJobs::UnknownLock < SidekiqUniqueJobs::UniqueJobsError
end
module SidekiqUniqueJobs::Script::Caller
  def call_script(file_name, *args); end
  def debug_lua; end
  def do_call(file_name, conn, keys, argv); end
  def extract_args(*args); end
  def max_history; end
  def normalize_argv(argv); end
  def now_f; end
  def redis_version; end
  def self.call_script(file_name, *args); end
  def self.debug_lua; end
  def self.do_call(file_name, conn, keys, argv); end
  def self.extract_args(*args); end
  def self.max_history; end
  def self.normalize_argv(argv); end
  def self.now_f; end
  def self.redis_version; end
  extend SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Connection
end
module SidekiqUniqueJobs::Normalizer
  def self.jsonify(args); end
  extend SidekiqUniqueJobs::JSON
end
module SidekiqUniqueJobs::Job
  def add_digest(item); end
  def add_lock_args(item); end
  def add_lock_digest(item); end
  def add_lock_prefix(item); end
  def add_lock_timeout(item); end
  def add_lock_ttl(item); end
  def add_lock_type(item); end
  def prepare(item); end
  def stringify_on_conflict_hash(item); end
  extend SidekiqUniqueJobs::Job
end
module SidekiqUniqueJobs::Redis
end
class SidekiqUniqueJobs::Redis::Entity
  def boolean?(value); end
  def count; end
  def exist?; end
  def expires?; end
  def initialize(key); end
  def key; end
  def pttl; end
  def ttl; end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Script::Caller
  include SidekiqUniqueJobs::Timing
end
class SidekiqUniqueJobs::Redis::Hash < SidekiqUniqueJobs::Redis::Entity
  def [](member); end
  def count; end
  def del(*fields); end
  def entries(with_values: nil); end
end
class SidekiqUniqueJobs::Redis::List < SidekiqUniqueJobs::Redis::Entity
  def count; end
  def entries; end
end
class SidekiqUniqueJobs::Redis::Set < SidekiqUniqueJobs::Redis::Entity
  def count; end
  def entries; end
end
class SidekiqUniqueJobs::Redis::SortedSet < SidekiqUniqueJobs::Redis::Entity
  def add(values); end
  def byscore(min, max, offset: nil, count: nil); end
  def clear; end
  def count; end
  def entries(with_scores: nil); end
  def rank(member); end
  def score(member); end
end
class SidekiqUniqueJobs::Redis::String < SidekiqUniqueJobs::Redis::Entity
  def count; end
  def del(*); end
  def set(obj, pipeline = nil); end
  def value; end
end
class SidekiqUniqueJobs::BatchDelete
  def batch_delete(conn); end
  def call; end
  def conn; end
  def del_digest(pipeline, digest); end
  def digests; end
  def initialize(digests, conn); end
  def keys_for_digest(digest); end
  def redis_version; end
  def self.call(digests, conn = nil); end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Logging
end
module SidekiqUniqueJobs::Orphans
end
class SidekiqUniqueJobs::Orphans::LuaReaper < SidekiqUniqueJobs::Orphans::Reaper
  def call; end
end
class SidekiqUniqueJobs::Orphans::RubyReaper < SidekiqUniqueJobs::Orphans::Reaper
  def active?(digest); end
  def belongs_to_job?(digest); end
  def call; end
  def considered_active?(time_f); end
  def digests; end
  def elapsed_ms; end
  def enqueued?(digest); end
  def entries(conn, queue, &block); end
  def expired_digests; end
  def in_sorted_set?(key, digest); end
  def initialize(conn); end
  def match?(key_one, key_two); end
  def max_score; end
  def orphaned_digests; end
  def orphans; end
  def queues(conn, &block); end
  def queues_very_full?; end
  def retried; end
  def retried?(digest); end
  def scheduled; end
  def scheduled?(digest); end
  def start_source; end
  def start_time; end
  def time_from_payload_timestamp(timestamp); end
  def timeout?; end
  def timeout_ms; end
  include SidekiqUniqueJobs::Timing
end
class SidekiqUniqueJobs::Orphans::NullReaper < SidekiqUniqueJobs::Orphans::Reaper
  def call; end
end
class SidekiqUniqueJobs::Orphans::Reaper
  def call; end
  def config; end
  def conn; end
  def initialize(conn); end
  def reaper; end
  def reaper_count; end
  def reaper_timeout; end
  def self.call(conn = nil); end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Script::Caller
end
class SidekiqUniqueJobs::Orphans::Observer
  def update(time, result, ex); end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Logging
end
module SidekiqUniqueJobs::Orphans::Manager
  def current_timestamp; end
  def default_task; end
  def disabled?; end
  def drift_reaper_interval; end
  def enabled?; end
  def logging_context; end
  def reaper; end
  def reaper_interval; end
  def refresh_reaper_mutex; end
  def register_reaper_process; end
  def registered?; end
  def self.current_timestamp; end
  def self.default_task; end
  def self.disabled?; end
  def self.drift_reaper_interval; end
  def self.enabled?; end
  def self.logging_context; end
  def self.reaper; end
  def self.reaper_interval; end
  def self.refresh_reaper_mutex; end
  def self.register_reaper_process; end
  def self.registered?; end
  def self.start(test_task = nil); end
  def self.stop; end
  def self.task; end
  def self.task=(task); end
  def self.timer_task_options; end
  def self.unregister_reaper_process; end
  def self.unregistered?; end
  def start(test_task = nil); end
  def stop; end
  def task; end
  def task=(task); end
  def timer_task_options; end
  def unregister_reaper_process; end
  def unregistered?; end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Logging
end
module SidekiqUniqueJobs::Orphans::ReaperResurrector
  def current_timestamp; end
  def drift_reaper_interval; end
  def logging_context; end
  def orphans_manager; end
  def reaper; end
  def reaper_disabled?; end
  def reaper_enabled?; end
  def reaper_interval; end
  def reaper_registered?; end
  def reaper_resurrector_interval; end
  def restart_if_dead; end
  def resurrector_disabled?; end
  def resurrector_enabled?; end
  def run_task; end
  def self.current_timestamp; end
  def self.drift_reaper_interval; end
  def self.logging_context; end
  def self.orphans_manager; end
  def self.reaper; end
  def self.reaper_disabled?; end
  def self.reaper_enabled?; end
  def self.reaper_interval; end
  def self.reaper_registered?; end
  def self.reaper_resurrector_interval; end
  def self.restart_if_dead; end
  def self.resurrector_disabled?; end
  def self.resurrector_enabled?; end
  def self.run_task; end
  def self.start; end
  def self.task; end
  def self.timer_task_options; end
  def start; end
  def task; end
  def timer_task_options; end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::Cli < Thor
  def console; end
  def console_class; end
  def count_entries_for_del(max_count, pattern); end
  def del(pattern); end
  def del_entries(max_count, pattern); end
  def digests; end
  def expiring_digests; end
  def list(pattern = nil); end
  def list_entries(entries, pattern); end
  def self.banner(command, _namespace = nil, _subcommand = nil); end
end
class Hash
end
class Array
end
class SidekiqUniqueJobs::LockTimeout
  def calculate; end
  def default_lock_timeout; end
  def initialize(item); end
  def item; end
  def self.calculate(item); end
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::LockTTL
  def calculate; end
  def calculate_timing(ttl); end
  def fetch_ttl; end
  def initialize(item); end
  def item; end
  def scheduled_at; end
  def self.calculate(item); end
  def time_until_scheduled; end
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::LockType
  def call; end
  def initialize(item); end
  def item; end
  def self.call(item); end
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::LockArgs
  def args; end
  def default_job_options; end
  def default_lock_args_method; end
  def filter_by_proc(args); end
  def filter_by_symbol(args); end
  def filtered_args; end
  def initialize(item); end
  def item; end
  def lock_args; end
  def lock_args_disabled?; end
  def lock_args_enabled?; end
  def lock_args_method; end
  def lock_args_method_valid?; end
  def self.call(item); end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::LockDigest
  def create_digest; end
  def digestable_hash; end
  def initialize(item); end
  def item; end
  def lock_args; end
  def lock_digest; end
  def lock_prefix; end
  def self.call(item); end
  def unique_across_queues?; end
  def unique_across_workers?; end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
module SidekiqUniqueJobs::Unlockable
  def delete!(item); end
  def delete(item); end
  def self.delete!(item); end
  def self.delete(item); end
  def self.unlock!(item); end
  def self.unlock(item); end
  def unlock!(item); end
  def unlock(item); end
end
class SidekiqUniqueJobs::Key
  def ==(other); end
  def changelog; end
  def digest; end
  def digests; end
  def expiring_digests; end
  def info; end
  def initialize(digest); end
  def inspect; end
  def locked; end
  def primed; end
  def queued; end
  def suffixed_key(variable); end
  def to_a; end
  def to_s; end
end
class SidekiqUniqueJobs::Locksmith
  def ==(other); end
  def add_drift(val); end
  def argv; end
  def brpoplpush(conn, wait); end
  def config; end
  def delete!; end
  def delete; end
  def drift(val); end
  def enqueue(conn); end
  def execute(&block); end
  def handle_primed(primed_jid); end
  def initialize(item, redis_pool = nil); end
  def inspect; end
  def item; end
  def job_id; end
  def key; end
  def lock!(conn, primed_method, wait = nil); end
  def lock(wait: nil); end
  def lock_info; end
  def lock_score; end
  def locked?(conn = nil); end
  def pop_queued(conn, wait = nil); end
  def primed_async(conn, wait = nil, &block); end
  def primed_sync(conn, wait = nil, &block); end
  def redis_pool; end
  def redis_version; end
  def rpoplpush(conn); end
  def taken?(conn); end
  def to_s; end
  def unlock!(conn = nil); end
  def unlock(conn = nil); end
  def write_lock_info(conn); end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Reflectable
  include SidekiqUniqueJobs::Script::Caller
  include SidekiqUniqueJobs::Timing
end
module SidekiqUniqueJobs::OptionsWithFallback
  def lock_class; end
  def lock_instance; end
  def lock_type; end
  def locks; end
  def options; end
  def self.included(base); end
  def unique_disabled?; end
  def unique_enabled?; end
end
class SidekiqUniqueJobs::Lock
  def add_digest_to_set(pipeline, lock_info, score = nil); end
  def all_jids; end
  def changelog; end
  def changelog_json(job_id, script, message); end
  def changelogs; end
  def created_at; end
  def del; end
  def digest; end
  def get_key(key); end
  def info; end
  def initialize(key, time: nil); end
  def inspect; end
  def key; end
  def lock(job_id, lock_info = nil, score = nil); end
  def locked; end
  def locked_jids(with_values: nil); end
  def prime(job_id); end
  def primed; end
  def primed_jids; end
  def queue(job_id); end
  def queued; end
  def queued_jids; end
  def self.create(digest, job_id, lock_info: nil, time: nil, score: nil); end
  def to_s; end
  def unlock(job_id); end
  extend SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Timing
end
class SidekiqUniqueJobs::LockConfig
  def errors; end
  def errors_as_string; end
  def initialize(job_hash = nil); end
  def job; end
  def limit; end
  def lock_info; end
  def lock_info?; end
  def on_client_conflict; end
  def on_conflict; end
  def on_server_conflict; end
  def pttl; end
  def self.from_worker(options); end
  def timeout; end
  def ttl; end
  def type; end
  def valid?; end
  def wait_for_lock?; end
end
class SidekiqUniqueJobs::LockInfo < SidekiqUniqueJobs::Redis::String
  def [](key); end
  def none?; end
  def present?; end
  def set(obj, pipeline = nil); end
  def value; end
end
class SidekiqUniqueJobs::Lock::BaseLock
  def attempt; end
  def call_strategy(origin:); end
  def callback; end
  def callback_safely; end
  def client_strategy; end
  def execute; end
  def initialize(item, callback, redis_pool = nil); end
  def item; end
  def lock; end
  def lock_config; end
  def locked?(*args, **, &block); end
  def locksmith; end
  def prepare_item; end
  def redis_pool; end
  def self.validate_options(options = nil); end
  def server_strategy; end
  def strategy_for(origin); end
  def unlock_and_callback; end
  extend Forwardable
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Reflectable
end
class SidekiqUniqueJobs::Lock::UntilExecuted < SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
  def lock(&block); end
end
class SidekiqUniqueJobs::Lock::UntilExecuting < SidekiqUniqueJobs::Lock::BaseLock
  def execute; end
  def lock(&block); end
end
class SidekiqUniqueJobs::Lock::UntilExpired < SidekiqUniqueJobs::Lock::UntilExecuted
  def execute(&block); end
  def lock(&block); end
end
class SidekiqUniqueJobs::Lock::WhileExecuting < SidekiqUniqueJobs::Lock::BaseLock
  def append_unique_key_suffix; end
  def execute(&block); end
  def initialize(item, callback, redis_pool = nil); end
  def lock; end
  extend SidekiqUniqueJobs::Logging::Middleware
  include SidekiqUniqueJobs::Logging::Middleware
  include SidekiqUniqueJobs::OptionsWithFallback
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::Lock::WhileExecutingReject < SidekiqUniqueJobs::Lock::WhileExecuting
  def server_strategy; end
end
class SidekiqUniqueJobs::Lock::UntilAndWhileExecuting < SidekiqUniqueJobs::Lock::BaseLock
  def ensure_relocked; end
  def execute; end
  def lock(origin: nil, &block); end
  def runtime_lock; end
end
module SidekiqUniqueJobs::Middleware
  def call(worker_class, item, queue, redis_pool = nil); end
  def item; end
  extend SidekiqUniqueJobs::Logging::Middleware
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging::Middleware
  include SidekiqUniqueJobs::OptionsWithFallback
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::Middleware::Client
  def call(worker_class, item, queue, redis_pool = nil); end
  def lock; end
  include Sidekiq::ServerMiddleware
  include SidekiqUniqueJobs::Reflectable
end
class SidekiqUniqueJobs::Middleware::Server
  def call(worker_class, item, queue, redis_pool = nil); end
  include Sidekiq::ServerMiddleware
end
module Sidekiq
end
class Sidekiq::SortedEntry < Sidekiq::JobRecord
end
module Sidekiq::SortedEntry::UniqueExtension
  def delete; end
  def remove_job; end
end
class Sidekiq::ScheduledSet < Sidekiq::JobSet
end
module Sidekiq::ScheduledSet::UniqueExtension
  def delete(score, job_id); end
end
class Sidekiq::JobRecord
end
module Sidekiq::JobRecord::UniqueExtension
  def delete; end
end
class Sidekiq::Queue
end
module Sidekiq::Queue::UniqueExtension
  def clear; end
end
class Sidekiq::JobSet < Sidekiq::SortedSet
end
module Sidekiq::JobSet::UniqueExtension
  def clear; end
  def delete_by_value(name, value); end
end
module SidekiqUniqueJobs::OnConflict
  def self.find_strategy(strategy); end
  def self.strategies; end
end
class SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def initialize(item, redis_pool = nil); end
  def item; end
  def redis_pool; end
  def replace?; end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Script::Caller
  include SidekiqUniqueJobs::Timing
end
class SidekiqUniqueJobs::OnConflict::NullStrategy < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end
class SidekiqUniqueJobs::OnConflict::Log < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::OnConflict::Raise < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
end
class SidekiqUniqueJobs::OnConflict::Reject < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def deadset; end
  def kill_job_with_options; end
  def kill_job_without_options; end
  def kill_with_options?; end
  def payload; end
  include SidekiqUniqueJobs::Timing
end
class SidekiqUniqueJobs::OnConflict::Replace < SidekiqUniqueJobs::OnConflict::Strategy
  def call(&block); end
  def delete_job_by_digest; end
  def delete_lock; end
  def digests; end
  def initialize(item, redis_pool = nil); end
  def lock_digest; end
  def queue; end
end
class SidekiqUniqueJobs::OnConflict::Reschedule < SidekiqUniqueJobs::OnConflict::Strategy
  def call; end
  def initialize(item, redis_pool = nil); end
  def schedule_in; end
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::JSON
  include SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Reflectable
  include SidekiqUniqueJobs::SidekiqWorkerMethods
end
class SidekiqUniqueJobs::Changelog < SidekiqUniqueJobs::Redis::SortedSet
  def add(message:, digest:, job_id:, script:); end
  def entries(pattern: nil, count: nil); end
  def initialize; end
  def page(cursor: nil, pattern: nil, page_size: nil); end
end
class SidekiqUniqueJobs::Digests < SidekiqUniqueJobs::Redis::SortedSet
  def add(digest); end
  def delete_by_digest(digest, queuetime: nil, runtime: nil); end
  def delete_by_pattern(pattern, count: nil); end
  def entries(pattern: nil, count: nil); end
  def initialize(digests_key = nil); end
  def page(cursor: nil, pattern: nil, page_size: nil); end
  def queuetime_keys(digest); end
  def runtime_keys(digest); end
end
class SidekiqUniqueJobs::ExpiringDigests < SidekiqUniqueJobs::Digests
  def initialize; end
end
class Concurrent::MutableStruct::ThreadSafeConfig < Concurrent::Synchronization::LockableObject
  def current_redis_version; end
  def current_redis_version=(value); end
  def debug_lua; end
  def debug_lua=(value); end
  def digest_algorithm; end
  def digest_algorithm=(value); end
  def enabled; end
  def enabled=(value); end
  def lock_info; end
  def lock_info=(value); end
  def lock_prefix; end
  def lock_prefix=(value); end
  def lock_timeout; end
  def lock_timeout=(value); end
  def lock_ttl; end
  def lock_ttl=(value); end
  def locks; end
  def locks=(value); end
  def logger; end
  def logger=(value); end
  def logger_enabled; end
  def logger_enabled=(value); end
  def max_history; end
  def max_history=(value); end
  def ns_initialize(*values); end
  def raise_on_config_error; end
  def raise_on_config_error=(value); end
  def reaper; end
  def reaper=(value); end
  def reaper_count; end
  def reaper_count=(value); end
  def reaper_interval; end
  def reaper_interval=(value); end
  def reaper_resurrector_enabled; end
  def reaper_resurrector_enabled=(value); end
  def reaper_resurrector_interval; end
  def reaper_resurrector_interval=(value); end
  def reaper_timeout; end
  def reaper_timeout=(value); end
  def self.[](*args, &block); end
  def strategies; end
  def strategies=(value); end
  include Concurrent::MutableStruct
end
class SidekiqUniqueJobs::Config < Concurrent::MutableStruct::ThreadSafeConfig
  def add_lock(name, klass); end
  def add_strategy(name, klass); end
  def class_name; end
  def default_lock_timeout; end
  def default_lock_timeout=(obj); end
  def default_lock_ttl; end
  def default_lock_ttl=(obj); end
  def digest_algorithm=(value); end
  def initialize(*); end
  def redis_version; end
  def self.default; end
end
class SidekiqUniqueJobs::UpdateVersion
  def self.call; end
end
class SidekiqUniqueJobs::UpgradeLocks
  def batch_delete(*keys); end
  def batch_scan(match:, count:); end
  def call; end
  def conn; end
  def delete_suffix(suffix); end
  def delete_supporting_v6_keys; end
  def delete_unused_v6_keys; end
  def initialize(conn); end
  def logging_context; end
  def now_f; end
  def redis_version; end
  def self.call; end
  def upgrade_v6_lock(grabbed_key); end
  def upgrade_v6_locks; end
  def upgraded_key; end
  def version; end
  extend SidekiqUniqueJobs::Connection
  extend SidekiqUniqueJobs::Logging
  include SidekiqUniqueJobs::Connection
  include SidekiqUniqueJobs::Logging
end
class SidekiqUniqueJobs::Server
  def self.configure(config); end
  def self.death_handler; end
  def self.start; end
  def self.stop; end
end
